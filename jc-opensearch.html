<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JAIRO Cloud OpenSearch クライアント</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
      font-family: sans-serif;
      font-size: 14px;
      color: #333;
      background: #f0f2f5;
      margin: 0;
      padding: 0;
    }
    #app { max-width: 960px; margin: 0 auto; padding: 0 16px 40px; }

    header {
      background: #003f7d;
      color: #fff;
      padding: 12px 16px;
      margin: 0 -16px 20px;
    }
    header h1 { font-size: 18px; font-weight: bold; margin: 0; }

    /* Search form */
    #search-section {
      background: #fff;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 20px;
    }
    .form-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .form-row label {
      width: 120px;
      flex-shrink: 0;
      color: #555;
      font-size: 13px;
    }
    .form-row input[type="text"],
    .form-row input[type="url"],
    .form-row select {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    .form-row input:focus,
    .form-row select:focus {
      outline: none;
      border-color: #0070c0;
      box-shadow: 0 0 0 2px rgba(0,112,192,0.15);
    }
    .form-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 12px;
    }
    #btn-search {
      background: #0070c0;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 8px 28px;
      font-size: 14px;
      cursor: pointer;
    }
    #btn-search:hover { background: #005fa3; }
    #btn-search:disabled { background: #aaa; cursor: not-allowed; }

    /* Messages */
    #error-msg {
      border-radius: 4px;
      padding: 12px 16px;
      margin-bottom: 16px;
      font-size: 13px;
      line-height: 1.8;
      white-space: pre-wrap;
    }
    #error-msg.warn {
      background: #fff3cd;
      border: 1px solid #ffc107;
    }
    #error-msg.cors {
      background: #f8d7da;
      border: 1px solid #f5c2c7;
    }
    #loading { text-align: center; padding: 32px; color: #888; }
    .hidden { display: none !important; }

    /* Result info */
    #result-info { font-size: 13px; color: #555; margin-bottom: 12px; }

    /* Item card */
    .item-card {
      background: #fff;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      padding: 14px 16px;
      margin-bottom: 10px;
    }
    .item-title {
      font-size: 15px;
      font-weight: bold;
      color: #0070c0;
      cursor: pointer;
      line-height: 1.4;
      display: inline-block;
      border: none;
      background: none;
      padding: 0;
      text-align: left;
    }
    .item-title:hover { text-decoration: underline; }
    .item-title::before { content: '▶\00a0'; font-size: 10px; color: #888; }
    .item-title.open::before { content: '▼\00a0'; }
    .item-meta { font-size: 13px; color: #555; margin-top: 4px; line-height: 1.5; }
    .item-files { font-size: 13px; margin-top: 4px; }
    .item-files a { color: #0070c0; margin-right: 12px; text-decoration: none; }
    .item-files a:hover { text-decoration: underline; }
    .item-url { font-size: 12px; color: #888; margin-top: 4px; }
    .item-url a { color: #888; }

    /* Expanded detail */
    .item-detail {
      margin-top: 12px;
      border-top: 1px solid #eee;
      padding-top: 12px;
    }
    .detail-table { width: 100%; border-collapse: collapse; font-size: 13px; }
    .detail-table tr { border-bottom: 1px solid #f0f0f0; }
    .detail-table th {
      width: 140px;
      text-align: left;
      vertical-align: top;
      padding: 5px 8px 5px 0;
      color: #666;
      font-weight: normal;
      white-space: nowrap;
    }
    .detail-table td { padding: 5px 8px; vertical-align: top; line-height: 1.6; }
    .detail-desc { white-space: pre-wrap; }
    .detail-lang { color: #888; font-size: 11px; }

    /* Pagination */
    #pagination {
      margin-top: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 13px;
    }
    .page-btn {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 6px 14px;
      cursor: pointer;
      font-size: 13px;
    }
    .page-btn:hover { background: #f0f0f0; }
    .page-btn:disabled { color: #aaa; cursor: not-allowed; }
    .page-info { color: #555; }
    .btn-inline {
      margin-left: 8px;
      flex-shrink: 0;
      padding: 6px 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #f6f8fa;
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
    }
    .btn-inline:hover { background: #e9ecef; }
    .btn-inline:disabled { color: #aaa; cursor: not-allowed; }
  </style>
</head>
<body>
<div id="app">
  <header>
    <h1>JAIRO Cloud OpenSearch クライアント</h1>
  </header>

  <section id="search-section">
    <div class="form-row">
      <label for="repo-url">リポジトリ URL</label>
      <input type="url" id="repo-url">
    </div>
    <div class="form-row">
      <label for="q-title">タイトル</label>
      <input type="text" id="q-title">
    </div>
    <div class="form-row">
      <label for="q-des">内容記述</label>
      <input type="text" id="q-des">
    </div>
    <div class="form-row">
      <label for="q-type">資源タイプ</label>
      <select id="q-type">
        <option value="">-- 指定なし --</option>
      </select>
    </div>
    <div class="form-row">
      <label for="q-iid">インデックス</label>
      <select id="q-iid" disabled>
        <option value="">-- リポジトリ URL を設定後に取得 --</option>
      </select>
      <button id="btn-fetch-tree" class="btn-inline" type="button">取得</button>
    </div>
    <div class="form-actions">
      <button id="btn-search">検索</button>
    </div>
  </section>

  <div id="error-msg" class="hidden"></div>
  <div id="loading" class="hidden">検索中…</div>

  <section id="results-section" class="hidden">
    <div id="result-info"></div>
    <div id="result-list"></div>
    <div id="pagination"></div>
  </section>
</div>

<script>
// ===== CONFIG =====
const CONFIG = {
  repositoryUrl: '',
  proxyUrl: ''
};
// ==================

// 資源タイプ語彙（docs/resource_type_vocabulary.md より）
const RESOURCE_TYPES = [
  { en: 'conference paper',        ja: '会議発表論文' },
  { en: 'data paper',              ja: 'データ論文' },
  { en: 'departmental bulletin paper', ja: '紀要論文' },
  { en: 'editorial',               ja: 'エディトリアル' },
  { en: 'journal article',         ja: '学術雑誌論文' },
  { en: 'newspaper',               ja: '新聞' },
  { en: 'periodical',              ja: '逐次刊行物' },
  { en: 'review article',          ja: 'レビュー論文' },
  { en: 'software paper',          ja: 'ソフトウェア論文' },
  { en: 'article',                 ja: '記事' },
  { en: 'book',                    ja: '図書' },
  { en: 'book part',               ja: '図書（部分）' },
  { en: 'cartographic material',   ja: '地図資料' },
  { en: 'map',                     ja: '地図' },
  { en: 'conference object',       ja: '会議発表資料' },
  { en: 'conference proceedings',  ja: '会議録' },
  { en: 'conference poster',       ja: '会議発表ポスター' },
  { en: 'dataset',                 ja: 'データセット' },
  { en: 'interview',               ja: 'インタビュー' },
  { en: 'image',                   ja: 'イメージ' },
  { en: 'still image',             ja: '静止画' },
  { en: 'moving image',            ja: '動画' },
  { en: 'video',                   ja: '録画資料' },
  { en: 'lecture',                 ja: '講演' },
  { en: 'patent',                  ja: '特許' },
  { en: 'internal report',         ja: '内部報告書' },
  { en: 'report',                  ja: '報告書' },
  { en: 'research report',         ja: '研究報告書' },
  { en: 'technical report',        ja: 'テクニカルレポート' },
  { en: 'policy report',           ja: 'ポリシーレポート' },
  { en: 'report part',             ja: '報告書（部分）' },
  { en: 'working paper',           ja: 'ワーキングペーパー' },
  { en: 'data management plan',    ja: 'データ管理計画' },
  { en: 'sound',                   ja: '音声・音楽' },
  { en: 'thesis',                  ja: '学位論文' },
  { en: 'bachelor thesis',         ja: '学士論文' },
  { en: 'master thesis',           ja: '修士論文' },
  { en: 'doctoral thesis',         ja: '博士論文' },
  { en: 'interactive resource',    ja: 'インタラクティブリソース' },
  { en: 'learning object',         ja: '教材' },
  { en: 'manuscript',              ja: '手稿' },
  { en: 'musical notation',        ja: '楽譜' },
  { en: 'research proposal',       ja: '研究計画書' },
  { en: 'software',                ja: 'ソフトウェア' },
  { en: 'technical documentation', ja: '技術文書' },
  { en: 'workflow',                ja: 'ワークフロー' },
  { en: 'other',                   ja: 'その他' },
];

// JPCOAR 要素の日本語ラベル
const FIELD_LABELS = {
  title:                  'タイトル',
  creator:                '作成者',
  creatorName:            '氏名',
  familyName:             '姓',
  givenName:              '名',
  contributor:            '寄与者',
  accessRights:           'アクセス権',
  rights:                 '権利',
  subject:                '件名',
  description:            '内容記述',
  publisher:              '出版者',
  date:                   '日付',
  language:               '言語',
  type:                   '資源タイプ',
  version:                'バージョン',
  identifierRegistration: '識別子登録',
  sourceIdentifier:       '収録物識別子',
  sourceTitle:            '収録物名',
  volume:                 '巻',
  issue:                  '号',
  numPages:               'ページ数',
  pageStart:              '開始ページ',
  pageEnd:                '終了ページ',
  conference:             '会議情報',
  file:                   'ファイル',
  URI:                    'ファイル URL',
  mimeType:               'MIME タイプ',
  extent:                 'サイズ',
};

// サマリー行に表示済みのため展開ビューでスキップするフィールド
const SUMMARY_FIELDS = new Set([
  'title', 'creator',
  'sourceTitle', 'volume', 'issue', 'pageStart', 'pageEnd',
  'file',
]);

const PAGE_SIZE = 20;
const NS_RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';

let state = { page: 1, query: {}, totalResults: 0 };

// ---- ユーティリティ ----

function esc(str) {
  return String(str ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function xmlLang(el) {
  return el.getAttribute('xml:lang') || '';
}

// parent の直接の子要素のうち localName が一致するものを返す
function children(parent, localName) {
  return Array.from(parent.children).filter(e => e.localName === localName);
}

// xml:lang が lang に一致する要素を優先して返す（なければ lang 属性なし、さらになければ先頭）
function pickByLang(els, lang) {
  return els.find(e => xmlLang(e) === lang)
    || els.find(e => !xmlLang(e))
    || els[0]
    || null;
}

// ---- URL 構築 ----

function buildUrl(query, page) {
  const repoUrl = document.getElementById('repo-url').value.trim() || CONFIG.repositoryUrl;
  const base = new URL(repoUrl).origin + '/';
  const params = new URLSearchParams({ format: 'jpcoar', size: PAGE_SIZE, page });
  if (query.title) params.set('title', query.title);
  if (query.des)   params.set('des',   query.des);
  if (query.type)  params.set('type',  query.type);
  if (query.iid)   params.set('iid',   query.iid);
  if (CONFIG.proxyUrl) {
    params.set('repo', repoUrl);
    return `${CONFIG.proxyUrl}?${params}`;
  }
  return `${base}api/opensearch/search?${params}`;
}

// ---- XML パース ----

function parseXML(xmlText) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText, 'application/xml');
  if (xml.querySelector('parsererror')) throw new Error('XML解析エラー');

  const getNum = (localName, fallback) => {
    const el = Array.from(xml.getElementsByTagName('*')).find(e => e.localName === localName);
    return parseInt(el?.textContent || fallback, 10);
  };
  const totalResults = getNum('totalResults', 0);
  const startIndex   = getNum('startIndex', 1);

  const descriptions = xml.getElementsByTagNameNS(NS_RDF, 'Description');
  const items = Array.from(descriptions).map(parseItem);

  return { totalResults, startIndex, items };
}

function parseItem(desc) {
  const itemUrl = desc.getAttributeNS(NS_RDF, 'about') || desc.getAttribute('rdf:about') || '';
  const jpcoarEl = desc.firstElementChild;
  if (!jpcoarEl) return { itemUrl, titles: [], creators: [], sourceTitle: '', volume: '', issue: '', pageStart: '', pageEnd: '', issuedDate: '', files: [], jpcoarEl: null };

  const byName = n => children(jpcoarEl, n);

  // タイトル
  const titles = byName('title').map(el => ({ text: el.textContent.trim(), lang: xmlLang(el) }));
  const primaryLang = titles[0]?.lang || '';

  // 作成者（タイトルと同じ言語の氏名を優先）
  const creators = byName('creator').map(creatorEl => {
    const cc = Array.from(creatorEl.children);
    const names = cc.filter(e => e.localName === 'creatorName');
    const nameEl = pickByLang(names, primaryLang);
    if (nameEl) return nameEl.textContent.trim();

    // フォールバック: 姓・名を結合
    const fam = pickByLang(cc.filter(e => e.localName === 'familyName'), primaryLang)?.textContent.trim() || '';
    const giv = pickByLang(cc.filter(e => e.localName === 'givenName'),  primaryLang)?.textContent.trim() || '';
    return [fam, giv].filter(Boolean).join(', ') || null;
  }).filter(Boolean);

  // 書誌情報
  const sourceTitle = byName('sourceTitle')[0]?.textContent.trim() || '';
  const volume      = byName('volume')[0]?.textContent.trim() || '';
  const issue       = byName('issue')[0]?.textContent.trim() || '';
  const pageStart   = byName('pageStart')[0]?.textContent.trim() || '';
  const pageEnd     = byName('pageEnd')[0]?.textContent.trim() || '';

  // 発行日（datacite:date dateType="Issued"）
  const issuedDate = byName('date')
    .find(e => e.getAttribute('dateType') === 'Issued')
    ?.textContent.trim() || '';

  // ファイル（jpcoar:URI のラベル属性と URL）
  const files = byName('file').map(fileEl => {
    const fc = Array.from(fileEl.children);
    const uriEl = fc.find(e => e.localName === 'URI' || e.localName === 'uri');
    const dcTitle = fc.find(e => e.localName === 'title');
    const label = dcTitle?.textContent.trim() || uriEl?.getAttribute('label') || '(ファイル)';
    const url   = uriEl?.textContent.trim() || '';
    return url ? { label, url } : null;
  }).filter(Boolean);

  return { itemUrl, titles, creators, sourceTitle, volume, issue, pageStart, pageEnd, issuedDate, files, jpcoarEl };
}

// ---- レンダリング ----

function renderResults(data) {
  const { totalResults, startIndex, items } = data;

  if (totalResults === 0) {
    document.getElementById('result-info').textContent = '検索結果はありませんでした。';
    document.getElementById('result-list').innerHTML = '';
    document.getElementById('pagination').innerHTML = '';
    document.getElementById('results-section').classList.remove('hidden');
    return;
  }

  const endIndex = startIndex + items.length - 1;
  document.getElementById('result-info').textContent =
    `${totalResults.toLocaleString()} 件中 ${startIndex}〜${endIndex} 件目`;

  const list = document.getElementById('result-list');
  list.innerHTML = '';
  items.forEach(item => list.appendChild(renderItem(item)));

  renderPagination(totalResults, state.page);
  document.getElementById('results-section').classList.remove('hidden');
  window.scrollTo({ top: document.getElementById('results-section').offsetTop - 16, behavior: 'smooth' });
}

function renderItem(item) {
  const { itemUrl, titles, creators, sourceTitle, volume, issue, pageStart, pageEnd, issuedDate, files, jpcoarEl } = item;

  const card = document.createElement('div');
  card.className = 'item-card';

  // タイトル（クリックで展開）
  const titleBtn = document.createElement('button');
  titleBtn.className = 'item-title';
  titleBtn.textContent = titles[0]?.text || '(タイトルなし)';
  card.appendChild(titleBtn);

  // 作成者・書誌情報行
  const parts = [];
  if (creators.length > 0) parts.push(creators.join('; '));
  const bib = buildBiblio(sourceTitle, volume, issue, pageStart, pageEnd, issuedDate);
  if (bib) parts.push(bib);
  if (parts.length > 0) {
    const meta = document.createElement('div');
    meta.className = 'item-meta';
    meta.textContent = parts.join('  ');
    card.appendChild(meta);
  }

  // ファイルリンク
  if (files.length > 0) {
    const filesDiv = document.createElement('div');
    filesDiv.className = 'item-files';
    files.forEach(f => {
      const a = document.createElement('a');
      a.href = f.url;
      a.target = '_blank';
      a.rel = 'noopener';
      a.textContent = `[${f.label}]`;
      filesDiv.appendChild(a);
    });
    card.appendChild(filesDiv);
  }

  // アイテム URL
  if (itemUrl) {
    const urlDiv = document.createElement('div');
    urlDiv.className = 'item-url';
    const a = document.createElement('a');
    a.href = itemUrl;
    a.target = '_blank';
    a.rel = 'noopener';
    a.textContent = itemUrl;
    urlDiv.appendChild(a);
    card.appendChild(urlDiv);
  }

  // 展開エリア（初期非表示）
  const detail = document.createElement('div');
  detail.className = 'item-detail hidden';
  if (jpcoarEl) detail.appendChild(renderExpandedFields(jpcoarEl));
  card.appendChild(detail);

  // クリックで展開/折りたたみ
  titleBtn.addEventListener('click', () => {
    const isOpen = titleBtn.classList.toggle('open');
    detail.classList.toggle('hidden', !isOpen);
  });

  return card;
}

function buildBiblio(sourceTitle, volume, issue, pageStart, pageEnd, issuedDate) {
  if (!sourceTitle && !issuedDate) return '';
  let s = sourceTitle;
  if (volume) {
    s += ' ' + volume;
    if (issue) s += '(' + issue + ')';
  }
  if (pageStart) {
    s += ', ' + pageStart;
    if (pageEnd) s += '-' + pageEnd;
  }
  if (issuedDate) s += ', ' + issuedDate;
  return s;
}

// ---- 展開フィールド ----

function renderExpandedFields(jpcoarEl) {
  const table = document.createElement('table');
  table.className = 'detail-table';

  Array.from(jpcoarEl.children).forEach(el => {
    const ln = el.localName;

    // サマリー表示済みフィールドをスキップ
    if (SUMMARY_FIELDS.has(ln)) return;
    // 発行日はサマリーに表示済みのためスキップ
    if (ln === 'date' && el.getAttribute('dateType') === 'Issued') return;
    // 空の conference をスキップ
    if (ln === 'conference' && !el.textContent.trim()) return;

    const label = FIELD_LABELS[ln] || ln;
    const td = document.createElement('td');

    if (ln === 'description') {
      const lang = xmlLang(el);
      const div = document.createElement('div');
      div.className = 'detail-desc';
      div.textContent = el.textContent.trim();
      td.appendChild(div);
      if (lang) appendLang(td, lang);

    } else if (ln === 'subject') {
      const lang   = xmlLang(el);
      const scheme = el.getAttribute('subjectScheme') || '';
      td.textContent = el.textContent.trim();
      const tag = [lang, scheme].filter(Boolean).join(', ');
      if (tag) appendLang(td, tag);

    } else if (ln === 'date') {
      const dateType = el.getAttribute('dateType') || '';
      td.textContent = el.textContent.trim();
      if (dateType) appendLang(td, dateType);

    } else if (ln === 'type') {
      td.textContent = el.textContent.trim();

    } else if (ln === 'identifierRegistration' || ln === 'sourceIdentifier') {
      const idType = el.getAttribute('identifierType') || '';
      td.textContent = el.textContent.trim();
      if (idType) appendLang(td, idType);

    } else if (ln === 'accessRights') {
      td.textContent = el.textContent.trim();

    } else {
      // その他: テキストのみ（子要素があれば子のテキストをまとめる）
      const elChildren = Array.from(el.children);
      if (elChildren.length === 0) {
        td.textContent = el.textContent.trim();
      } else {
        elChildren.forEach(c => {
          if (!c.textContent.trim()) return;
          const cLabel = FIELD_LABELS[c.localName] || c.localName;
          const lang   = xmlLang(c);
          const line   = document.createElement('div');
          line.textContent = `${cLabel}: ${c.textContent.trim()}`;
          if (lang) appendLang(line, lang);
          td.appendChild(line);
        });
      }
    }

    if (!td.textContent.trim() && !td.querySelector('a')) return; // 空行スキップ

    const tr = document.createElement('tr');
    const th = document.createElement('th');
    th.textContent = label;
    tr.appendChild(th);
    tr.appendChild(td);
    table.appendChild(tr);
  });

  return table;
}

function appendLang(parent, tag) {
  const span = document.createElement('span');
  span.className = 'detail-lang';
  span.textContent = ` (${tag})`;
  parent.appendChild(span);
}

// ---- ページング ----

function renderPagination(totalResults, currentPage) {
  const totalPages = Math.ceil(totalResults / PAGE_SIZE);
  const pag = document.getElementById('pagination');
  pag.innerHTML = '';
  if (totalPages <= 1) return;

  const prevBtn = document.createElement('button');
  prevBtn.className = 'page-btn';
  prevBtn.textContent = '◀ 前へ';
  prevBtn.disabled = currentPage <= 1;
  prevBtn.addEventListener('click', () => doSearch(currentPage - 1));
  pag.appendChild(prevBtn);

  const info = document.createElement('span');
  info.className = 'page-info';
  info.textContent = `${currentPage} / ${totalPages} ページ`;
  pag.appendChild(info);

  const nextBtn = document.createElement('button');
  nextBtn.className = 'page-btn';
  nextBtn.textContent = '次へ ▶';
  nextBtn.disabled = currentPage >= totalPages;
  nextBtn.addEventListener('click', () => doSearch(currentPage + 1));
  pag.appendChild(nextBtn);
}

// ---- インデックスツリー取得 ----

let treeFetchInProgress = false;

async function fetchIndexTree() {
  if (treeFetchInProgress) return;
  const repoVal = document.getElementById('repo-url').value.trim() || CONFIG.repositoryUrl;
  const select = document.getElementById('q-iid');
  const btn = document.getElementById('btn-fetch-tree');

  if (!repoVal) {
    select.innerHTML = '<option value="">-- リポジトリ URL を入力してください --</option>';
    select.disabled = true;
    return;
  }

  treeFetchInProgress = true;
  select.innerHTML = '<option value="">-- 取得中… --</option>';
  select.disabled = true;
  btn.disabled = true;

  try {
    let treeUrl;
    if (CONFIG.proxyUrl) {
      const params = new URLSearchParams({ repo: repoVal, path: '/api/tree' });
      treeUrl = `${CONFIG.proxyUrl}?${params}`;
    } else {
      treeUrl = `${new URL(repoVal).origin}/api/tree`;
    }
    const res = await fetch(treeUrl);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    console.log('[IndexTree] raw response:', data);

    // WEKO3 のレスポンス形式に合わせて配列を取り出す
    let nodes = null;
    if (Array.isArray(data))                               nodes = data;
    else if (data && Array.isArray(data.data))             nodes = data.data;
    else if (data && Array.isArray(data.hits))             nodes = data.hits;
    else if (data && data.hits && Array.isArray(data.hits.hits)) nodes = data.hits.hits;

    if (nodes && nodes.length > 0) {
      select.innerHTML = '<option value="">-- 指定なし --</option>';
      addTreeNodes(select, nodes, 0);
      select.disabled = false;
    } else {
      console.warn('[IndexTree] 認識できる配列なし。raw response を確認してください。');
      select.innerHTML = '<option value="">-- インデックスが見つかりません --</option>';
    }
  } catch (err) {
    console.error('[IndexTree] fetch エラー:', err);
    select.innerHTML = `<option value="">-- 取得に失敗しました: ${err.message} --</option>`;
  } finally {
    treeFetchInProgress = false;
    btn.disabled = false;
  }
}

function addTreeNodes(select, nodes, depth) {
  nodes.forEach(node => {
    const id = node.id ?? '';
    const label = node.value || node.name || String(id);
    if (id === '' && !label) return;
    const opt = document.createElement('option');
    opt.value = String(id);
    opt.textContent = '\u00a0\u00a0'.repeat(depth) + label;
    select.appendChild(opt);
    if (Array.isArray(node.children) && node.children.length > 0) {
      addTreeNodes(select, node.children, depth + 1);
    }
  });
}

// ---- 検索実行 ----

async function doSearch(page = 1) {
  const query = {
    title: document.getElementById('q-title').value.trim(),
    des:   document.getElementById('q-des').value.trim(),
    type:  document.getElementById('q-type').value,
    iid:   document.getElementById('q-iid').value,
  };
  const repoVal = document.getElementById('repo-url').value.trim() || CONFIG.repositoryUrl;
  if (!repoVal) {
    showError('リポジトリ URL を入力してください。', 'warn');
    document.getElementById('repo-url').focus();
    return;
  }
  if (!query.title && !query.des && !query.type && !query.iid) {
    showError('検索条件を 1 つ以上入力してください。', 'warn');
    return;
  }

  state.page  = page;
  state.query = query;
  setLoading(true);
  hideError();

  try {
    const res = await fetch(buildUrl(query, page));
    if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    const text = await res.text();
    renderResults(parseXML(text));
  } catch (err) {
    const isCors = err instanceof TypeError && err.message === 'Failed to fetch';
    const msg = isCors
      ? (CONFIG.proxyUrl
          ? `接続エラー: プロキシ（${CONFIG.proxyUrl}）経由でのアクセスに失敗しました。プロキシの設定を確認してください。`
          : 'CORS エラー: ブラウザが API へのアクセスをブロックしました。\n\n以下のいずれかの方法で解決できます:\n① ブラウザ拡張機能「Allow CORS: Access-Control-Allow-Headers」等を有効化する\n② Chrome を --disable-web-security フラグ付きで起動する')
      : `エラー: ${err.message}`;
    showError(msg, isCors ? 'cors' : 'warn');
  } finally {
    setLoading(false);
  }
}

function setLoading(on) {
  document.getElementById('loading').classList.toggle('hidden', !on);
  document.getElementById('btn-search').disabled = on;
  if (on) document.getElementById('results-section').classList.add('hidden');
}

function showError(msg, type = 'warn') {
  const el = document.getElementById('error-msg');
  el.textContent = msg;
  el.className = type;
  el.classList.remove('hidden');
}

function hideError() {
  document.getElementById('error-msg').classList.add('hidden');
}

// ---- 初期化 ----

function init() {
  document.getElementById('repo-url').value = CONFIG.repositoryUrl;

  const select = document.getElementById('q-type');
  RESOURCE_TYPES.forEach(rt => {
    const opt = document.createElement('option');
    opt.value = rt.en;
    opt.textContent = `${rt.ja} (${rt.en})`;
    select.appendChild(opt);
  });

  document.getElementById('btn-search').addEventListener('click', () => doSearch(1));
  document.getElementById('btn-fetch-tree').addEventListener('click', fetchIndexTree);
  document.getElementById('repo-url').addEventListener('change', () => {
    const select = document.getElementById('q-iid');
    select.innerHTML = '<option value="">-- 取得ボタンで更新 --</option>';
    select.disabled = true;
  });

  ['q-title', 'q-des'].forEach(id => {
    document.getElementById(id).addEventListener('keydown', e => {
      if (e.key === 'Enter') doSearch(1);
    });
  });

  if (CONFIG.repositoryUrl) fetchIndexTree();
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
